using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using ToStringSourceGenerator.Attributes;
using ToStringSourceGenerator.Utils;

namespace ToStringSourceGenerator.Generators;

public sealed class DefaultToStringGenerator
{
    private const char _valuesSeparator = ',';
    private const char _propertySeparator = ':';

    private readonly GeneratorExecutionContext _context;
    private readonly AttributeSymbols _attributes;

    internal bool ShouldUseGenerator(INamedTypeSymbol symbol)
    {
        return CompilationHelper.SymbolContainsAttribute(symbol, _attributes.Auto);
    }

    public DefaultToStringGenerator(GeneratorExecutionContext context, AttributeSymbols attributes)
    {
        _context = context;
        _attributes = attributes;
    }

    internal void WriteType(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
    {
        if (!CompilationHelper.IsPartial(type))
        {
            Report_ClassMustBePartial(type);
        }
        else if (ContainsToStringMethodWithNoArguments(type))
        {
            Report_ClassContainsToStringWithNoArguments(type, GetToStringMethodWithNoArguments(type));
        }
        else if (!GetSymbolsForToString(type, _attributes.Skip).Any())
        {
            Report_NoPropertiesFoundOnMethod(type);
        }
        else
        {
            WritePartialClassSourceTextTo(type, indentedTextWriter);
        }

    }

    private void WritePartialClassSourceTextTo(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
    {
        // TODO Comprobar si contiene to string

        indentedTextWriter.WriteLine();
        indentedTextWriter.WriteLine($"namespace {type.ContainingNamespace}");
        indentedTextWriter.WriteLine("{");
        indentedTextWriter.Indent++;
        indentedTextWriter.WriteLine("using System;");
        indentedTextWriter.WriteLine();
        indentedTextWriter.WriteLine($"partial class {type.Name}");
        indentedTextWriter.WriteLine("{");
        indentedTextWriter.Indent++;

        indentedTextWriter.WriteLine("public override string ToString()");
        indentedTextWriter.WriteLine("{");
        indentedTextWriter.Indent++;

        //indentedTextWriter.WriteLine("return \"I am autogenerated\";");
        WriteToStringMethodBody(type, indentedTextWriter);
        indentedTextWriter.Indent--;
        indentedTextWriter.WriteLine("}");

        indentedTextWriter.Indent--;
        indentedTextWriter.WriteLine("}");

        indentedTextWriter.Indent--;
        indentedTextWriter.WriteLine("}");
    }
    private void WriteToStringMethodBody(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
    {
        indentedTextWriter.Write("return $\"");
        var stringValueInMethod = new StringBuilder();

        var count = 0;
        foreach (var propertySymbol in GetSymbolsForToString(type, _attributes.Skip))
        {
            if(count > 0)
                stringValueInMethod.Append(' ');
            stringValueInMethod.Append(propertySymbol.Name);
            stringValueInMethod.Append(_propertySeparator);
            stringValueInMethod.Append(' '); // Add space

            WritePropertyValueToStringRepresentation(stringValueInMethod, propertySymbol, _attributes.Format);

            stringValueInMethod.Append(_valuesSeparator); // Add value separator

            count++;
        }

        // remove trailing separator
        stringValueInMethod.Length -= 1;
        indentedTextWriter.Write(stringValueInMethod.ToString());
        indentedTextWriter.Write("\";");
    }
    private static void WritePropertyValueToStringRepresentation(StringBuilder sb, IPropertySymbol namedTypeSymbol, INamedTypeSymbol formatAttributeSymbol)
    {
        var propertyVauleEnclosingDelimiter = ObjectSeparatorTokensExtensions.GetSeparatorFor(namedTypeSymbol.Type.SpecialType);
        sb.Append(propertyVauleEnclosingDelimiter.GetOpeningSeparatorFor());

        var attributeFormatString = CompilationHelper.GetAttributesOfType(namedTypeSymbol, formatAttributeSymbol).SingleOrDefault();
        if (attributeFormatString != null)
        {
            var format = GetFirstConstructorArgumentValueOfAttribute(attributeFormatString);
            sb.Append($"{{{namedTypeSymbol.Name}:{format}}}");
        }
        else
        {
            sb.Append($"{{{namedTypeSymbol.Name}}}");
        }

        sb.Append(propertyVauleEnclosingDelimiter.GetClosingSeparatorFor());
    }
    private void Report_MultiplesFormatStringAttributesApplied(INamedTypeSymbol type)
    {
        // TODO Reportar mejor la localizacion
        _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(FormatToStringAttribute),
                nameof(FormatToStringAttribute),
                $"Multiples attributes form No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
            type.Locations.FirstOrDefault() ?? Location.None
        ));
    }
    private void Report_NoPropertiesFoundOnMethod(INamedTypeSymbol type)
    {
        // TODO Reportar mejor la localizacion
        _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
            type.Locations.FirstOrDefault() ?? Location.None
        ));
    }
    private void Report_ClassMustBePartial(INamedTypeSymbol type)
    {
        // TODO Reportar mejor la localizacion
        _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"'{type.ContainingNamespace}.{type.Name}' class must be partial, if '{typeof(AutoToStringAttribute).FullName}' is used",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
            type.Locations.FirstOrDefault() ?? Location.None
        ));
    }
    private void Report_ClassContainsToStringWithNoArguments(INamedTypeSymbol type, IMethodSymbol? method)
    {
        // TODO Reportar mejor la localizacion
        _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"Method 'ToString()' can not be overriden, in type '{type.ContainingNamespace}.{type.Name}' if has attribute '{typeof(AutoToStringAttribute).FullName}'",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Error,
                true),
            method?.Locations.FirstOrDefault() ?? Location.None
        ));
    }
    private static bool ContainsToStringMethodWithNoArguments(ITypeSymbol type)
    {
        return GetToStringMethodWithNoArguments(type) != null;
    }
    private static IEnumerable<IPropertySymbol> GetSymbolsForToString(INamedTypeSymbol type, INamedTypeSymbol skipAttributeSymbol)
    {
        foreach (var typeProperty in type.GetMembers().Where(t => t.Kind == SymbolKind.Property))
        {
            if (typeProperty is IPropertySymbol propertySymbol)
            {
                var visible = propertySymbol.DeclaredAccessibility == Accessibility.Public || propertySymbol.DeclaredAccessibility == Accessibility.Internal;
                var containsSkipAttribute = CompilationHelper.SymbolContainsAttribute(propertySymbol, skipAttributeSymbol);

                if (visible && !containsSkipAttribute)
                {
                    yield return propertySymbol;
                }
            }
        }
    }
    private static IMethodSymbol? GetToStringMethodWithNoArguments(ITypeSymbol type)
    {
        var toStringMembers = type.GetMembers("ToString");
        foreach (var toStringMember in toStringMembers)
        {
            if (toStringMember is IMethodSymbol toStringMethodSymbol)
            {
                if (toStringMethodSymbol.Parameters.Length == 0)
                    return toStringMethodSymbol;
            }
        }
        return null;
    }
    private static string? GetFirstConstructorArgumentValueOfAttribute(AttributeData data)
    {
        var constructorArgument = data.ConstructorArguments.First();
        return (string?)constructorArgument.Value;
    }



}